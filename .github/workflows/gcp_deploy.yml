name: Deploy to Cloud Run

on:
  # Push only on main branch (for direct commits and merge commits)
  push:
    branches: [main]
    paths:
      - ".github/workflows/gcp_deploy.yml"
  # Pull request on all branches (for PR checks / validation)
  pull_request:
    paths:
      - ".github/workflows/gcp_deploy.yml"
  # Trigger only after database migrations pipeline completes
  # This ensures migrations are applied before deployment and avoids duplicate deployments
  workflow_run:
    workflows: ["Database Migrations"]
    branches: [main]
    types:
      - completed

# Cancel in-progress runs for the same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.ref_name }}
  cancel-in-progress: true

env:
  PROJECT_ID: mobileid-478800
  REGION: us-west1
  SERVICE_NAME: mobileid

jobs:
  # Validate workflow syntax when file changes (for push/PR events)
  validate:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'pull_request'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate workflow syntax
        run: |
          echo "Validating gcp_deploy.yml workflow syntax..."
          # Check YAML syntax using yq
          if command -v yq &> /dev/null; then
            yq e '.' .github/workflows/gcp_deploy.yml > /dev/null
          fi
          echo "[PASS] Workflow file syntax is valid"

  deploy:
    runs-on: ubuntu-latest
    # Only run if Database Migrations workflow succeeded AND triggered from main branch
    # Skip for push/PR events (those are handled by validate job)
    if: >-
      github.event_name == 'workflow_run' &&
      github.event.workflow_run.conclusion == 'success' &&
      github.event.workflow_run.head_branch == 'main'

    environment:
      name: MobileID Backend (Google Cloud - Production)
      url: https://${{ env.SERVICE_NAME }}-${{ env.REGION }}.a.run.app

    permissions:
      contents: "read"
      id-token: "write"
      deployments: "write"

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Use workflow_run's head_sha if triggered by workflow_run, otherwise use default
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Google Auth
        uses: google-github-actions/auth@v2
        with:
          credentials_json: "${{ secrets.GCP_SA_KEY }}"

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      # ---------- Create Deployment Record ----------
      - name: Create GitHub Deployment
        id: create_deploy
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          environment: MobileID Backend (Google Cloud - Production)
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}
          description: "Deploying MobileID Backend to Google Cloud Run"
          auto-merge: false

      # ---------- Build and Deploy ----------
      - name: Build and Push Container
        run: |-
          gcloud builds submit src --tag gcr.io/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}

      - name: Deploy to Cloud Run
        id: deploy_cloudrun
        uses: google-github-actions/deploy-cloudrun@v2
        with:
          service: ${{ env.SERVICE_NAME }}
          region: ${{ env.REGION }}
          image: gcr.io/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}
          flags: "--add-cloudsql-instances=${{ secrets.INSTANCE_CONNECTION_NAME }} --allow-unauthenticated"
          env_vars: |-
            DB_NAME=${{ secrets.DB_NAME }}
            DB_USER=${{ secrets.DB_USER }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            INSTANCE_CONNECTION_NAME=${{ secrets.INSTANCE_CONNECTION_NAME }}
            GCP_PROJECT_ID=${{ env.PROJECT_ID }}
            DJANGO_SETTINGS_MODULE=core.settings.prod

            DJANGO_SUPERUSER_USERNAME=${{ secrets.DJANGO_SUPERUSER_USERNAME }}
            DJANGO_SUPERUSER_EMAIL=${{ secrets.DJANGO_SUPERUSER_EMAIL }}
            DJANGO_SUPERUSER_PASSWORD=${{ secrets.DJANGO_SUPERUSER_PASSWORD }}

            SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}

            ALLOWED_HOSTS=*
            DB_PROFILE=gcp
            DEBUG=False
            ENVIRONMENT=production

            CORS_ALLOWED_ORIGINS=*
            CSRF_TRUSTED_ORIGINS=https://*.run.app
            ADMIN_URL_PATH=${{ secrets.ADMIN_URL_PATH }}

      # ---------- Post-Deployment Health Check ----------
      - name: Wait for deployment to stabilize
        run: sleep 30

      - name: Health Check - API Root
        id: health_check
        run: |
          SERVICE_URL="${{ steps.deploy_cloudrun.outputs.url }}"
          echo "Checking health at: $SERVICE_URL"

          # Check API root endpoint
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$SERVICE_URL/" || echo "000")
          echo "API Root Response: $HTTP_CODE"

          if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 400 ]; then
            echo "::error::Health check failed: API root returned $HTTP_CODE"
            exit 1
          fi
          echo "[PASS] API root is responding"

      - name: Health Check - Health Endpoint
        run: |
          SERVICE_URL="${{ steps.deploy_cloudrun.outputs.url }}"

          # Check health endpoint
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$SERVICE_URL/health/" || echo "000")
          echo "Health Endpoint Response: $HTTP_CODE"

          if [ "$HTTP_CODE" -eq 200 ]; then
            echo "[PASS] Health endpoint is healthy"
          else
            echo "[WARN] Health endpoint returned $HTTP_CODE (endpoint may not exist)"
          fi

      - name: Smoke Test - API Endpoints
        run: |
          SERVICE_URL="${{ steps.deploy_cloudrun.outputs.url }}"

          echo "Running smoke tests..."

          # Test well-known endpoint
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$SERVICE_URL/.well-known/webauthn" || echo "000")
          echo "WebAuthn Well-Known: $HTTP_CODE"

          # Test API base
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$SERVICE_URL/api/" || echo "000")
          echo "API Base: $HTTP_CODE"

          echo "[PASS] Smoke tests completed"

      - name: Verify Cloud Run Service Status
        run: |
          echo "Verifying Cloud Run service..."
          gcloud run services describe ${{ env.SERVICE_NAME }} --region=${{ env.REGION }} --format="yaml(status)"

          # Check if service is serving traffic
          SERVING=$(gcloud run services describe ${{ env.SERVICE_NAME }} --region=${{ env.REGION }} --format="value(status.conditions[0].status)")
          if [ "$SERVING" != "True" ]; then
            echo "::error::Service is not in healthy state"
            exit 1
          fi
          echo "[PASS] Cloud Run service is healthy and serving traffic"

      - name: Mark Deployment Success
        if: success()
        uses: chrnorm/deployment-status@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          deployment-id: ${{ steps.create_deploy.outputs.deployment_id }}
          state: success
          environment-url: ${{ steps.deploy_cloudrun.outputs.url }}
          description: "MobileID Backend successfully deployed to Cloud Run"

      - name: Mark Deployment Failure
        if: failure()
        uses: chrnorm/deployment-status@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          deployment-id: ${{ steps.create_deploy.outputs.deployment_id }}
          state: failure
          description: "Deployment failed or Cloud Run verification error"

      # ---------- Rollback Logic ----------
      - name: Rollback on Failure
        if: failure()
        run: |-
          echo "Deployment failed, rolling back to previous revision..."
          LAST_REVISION=$(gcloud run revisions list --service=${{ env.SERVICE_NAME }} --region=${{ env.REGION }} --sort-by="~createTime" --limit=2 --format="value(metadata.name)" | tail -n 1)
          if [ -n "$LAST_REVISION" ]; then
            gcloud run services update-traffic ${{ env.SERVICE_NAME }} --region=${{ env.REGION }} --to-revisions=$LAST_REVISION=100
            echo "Rollback complete: now serving $LAST_REVISION"
          else
            echo "No previous revision found, skipping rollback."
          fi