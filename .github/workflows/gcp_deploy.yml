name: Deploy to Cloud Run

on:
  # Allow manual deployment trigger (main branch only enforced in job condition)
  workflow_dispatch:
  # Trigger only after Backend CI completes on main branch
  # This ensures tests/lints/migration checks pass before deployment
  workflow_run:
    workflows: ["Backend CI"]
    branches: [main]
    types:
      - completed

# Cancel in-progress runs for the same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.ref_name }}
  cancel-in-progress: true

env:
  PROJECT_ID: mobileid-478800
  REGION: us-west1
  SERVICE_NAME: mobileid
  MIGRATION_JOB_NAME: mobileid-migrate

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    # Only deploy when:
    # 1. Manual trigger on main branch by allowlisted user
    # 2. Backend CI workflow on this repo/main succeeded by allowlisted user
    # Allowed users: hongzhe, MacroXie04
    if: |
      (
        github.event_name == 'workflow_dispatch' &&
        github.ref == 'refs/heads/main' &&
        (github.actor == 'hongzhe' || github.actor == 'MacroXie04')
      ) ||
      (
        github.event_name == 'workflow_run' &&
        github.event.workflow_run.conclusion == 'success' &&
        github.event.workflow_run.head_branch == 'main' &&
        github.event.workflow_run.head_repository.full_name == github.repository &&
        (github.event.workflow_run.actor.login == 'hongzhe' || github.event.workflow_run.actor.login == 'MacroXie04')
      )

    environment:
      name: MobileID Backend (Google Cloud - Production)
      url: https://${{ env.SERVICE_NAME }}-${{ env.REGION }}.a.run.app

    permissions:
      contents: "read"
      id-token: "write"
      deployments: "write"
      actions: "read"

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Use workflow_run's head_sha if triggered by workflow_run, otherwise use default
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Wait for required security workflows
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const targetSha = context.payload.workflow_run?.head_sha || context.sha;
            const required = [
              { name: 'Security Scan', workflow_id: 'security_scan.yml' },
              { name: 'CodeQL Security Analysis', workflow_id: 'codeql.yml' },
            ];

            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
            const intervalSeconds = 30;
            const maxAttempts = Math.ceil((25 * 60) / intervalSeconds);

            core.info(`Waiting for required workflows on commit ${targetSha}`);

            for (const wf of required) {
              let completed = false;
              for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                const { data } = await github.rest.actions.listWorkflowRuns({
                  owner,
                  repo,
                  workflow_id: wf.workflow_id,
                  per_page: 20,
                });

                const run = data.workflow_runs.find((r) => r.head_sha === targetSha);
                if (run) {
                  core.info(`${wf.name}: status=${run.status} conclusion=${run.conclusion}`);
                  if (run.status === 'completed') {
                    if (run.conclusion !== 'success') {
                      throw new Error(`${wf.name} did not succeed (conclusion=${run.conclusion})`);
                    }
                    completed = true;
                    break;
                  }
                } else {
                  core.info(`${wf.name}: no run found yet`);
                }

                await sleep(intervalSeconds * 1000);
              }

              if (!completed) {
                throw new Error(`${wf.name} did not complete within timeout`);
              }
            }

      - name: Locate Backend CI run
        id: backend_ci
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const targetSha = context.payload.workflow_run?.head_sha || context.sha;
            const workflowId = 'backend_ci.yml';

            if (context.payload.workflow_run?.id) {
              core.setOutput('run_id', context.payload.workflow_run.id.toString());
              core.setOutput('head_sha', targetSha);
              return;
            }

            const { data } = await github.rest.actions.listWorkflowRuns({
              owner,
              repo,
              workflow_id: workflowId,
              per_page: 50,
            });

            const run = data.workflow_runs.find((r) => r.head_sha === targetSha && r.conclusion === 'success');
            if (!run) {
              throw new Error(`No successful Backend CI run found for commit ${targetSha}`);
            }

            core.setOutput('run_id', run.id.toString());
            core.setOutput('head_sha', targetSha);

      - name: Download backend image metadata
        uses: actions/download-artifact@v4
        with:
          name: backend-image
          run-id: ${{ steps.backend_ci.outputs.run_id }}
          path: .

      - name: Load image metadata
        id: image
        run: |
          python - <<'PY'
          import json
          import pathlib
          import sys
          import os

          path = pathlib.Path("image-info.json")
          if not path.exists():
            print("::error::image-info.json not found")
            sys.exit(1)

          data = json.loads(path.read_text())
          image_ref = data.get("image_ref")
          image = data.get("image")
          digest = data.get("digest")
          commit = data.get("commit")
          expected = os.environ.get("TARGET_SHA")

          if not image_ref or not digest:
            print("::error::image metadata incomplete")
            sys.exit(1)

          if expected and commit and commit != expected:
            print(f"::error::Image commit {commit} does not match expected {expected}")
            sys.exit(1)

          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
            f.write(f"image_ref={image_ref}\n")
            f.write(f"image={image}\n")
            f.write(f"digest={digest}\n")
            f.write(f"commit={commit}\n")
          PY
        env:
          TARGET_SHA: ${{ steps.backend_ci.outputs.head_sha }}

      - name: Print deployment info
        run: |
          echo "## Deployment Info" >> $GITHUB_STEP_SUMMARY
          echo "**Event:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit SHA:** ${{ steps.image.outputs.commit }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit Message:** $(git log -1 --pretty=%B)" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** ${{ steps.image.outputs.image_ref }}" >> $GITHUB_STEP_SUMMARY
          echo ""
          echo "Deploying commit: $(git rev-parse HEAD)"
          echo "Commit message: $(git log -1 --pretty=%B)"
          echo "Image ref: ${{ steps.image.outputs.image_ref }}"

      - name: Google Auth (Workload Identity)
        if: ${{ secrets.GCP_WIF_PROVIDER != '' && secrets.GCP_SERVICE_ACCOUNT_EMAIL != '' }}
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Google Auth (Service Account Key Fallback)
        if: ${{ secrets.GCP_WIF_PROVIDER == '' || secrets.GCP_SERVICE_ACCOUNT_EMAIL == '' }}
        uses: google-github-actions/auth@v2
        with:
          credentials_json: "${{ secrets.GCP_SA_KEY }}"

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure gcloud project
        run: gcloud config set project "${{ env.PROJECT_ID }}"

      # ---------- Deploy ----------
      # Note: GitHub Deployment record is automatically created by the job-level 'environment' setting
      # Deploy the exact image built by Backend CI (artifact promotion).

      - name: Run database migrations (Cloud Run Job)
        run: |
          JOB_NAME="${{ env.MIGRATION_JOB_NAME }}"
          IMAGE="${{ steps.image.outputs.image_ref }}"

          echo "Using migration job: ${JOB_NAME}"
          echo "Using image: ${IMAGE}"

          if ! gcloud run jobs describe "${JOB_NAME}" --region="${{ env.REGION }}" > /dev/null 2>&1; then
            echo "::error::Cloud Run Job '${JOB_NAME}' not found. Create it before deploying."
            exit 1
          fi

          gcloud run jobs update "${JOB_NAME}" --region="${{ env.REGION }}" --image="${IMAGE}"
          gcloud run jobs execute "${JOB_NAME}" --region="${{ env.REGION }}" --wait

      - name: Deploy to Cloud Run
        id: deploy_cloudrun
        uses: google-github-actions/deploy-cloudrun@v2
        with:
          service: ${{ env.SERVICE_NAME }}
          region: ${{ env.REGION }}
          image: ${{ steps.image.outputs.image_ref }}
          flags: "--add-cloudsql-instances=${{ secrets.INSTANCE_CONNECTION_NAME }} --allow-unauthenticated"
          env_vars: |-
            DB_NAME=${{ secrets.DB_NAME }}
            DB_USER=${{ secrets.DB_USER }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            INSTANCE_CONNECTION_NAME=${{ secrets.INSTANCE_CONNECTION_NAME }}
            GCP_PROJECT_ID=${{ env.PROJECT_ID }}
            DJANGO_SETTINGS_MODULE=core.settings.prod

            DJANGO_SUPERUSER_USERNAME=${{ secrets.DJANGO_SUPERUSER_USERNAME }}
            DJANGO_SUPERUSER_EMAIL=${{ secrets.DJANGO_SUPERUSER_EMAIL }}
            DJANGO_SUPERUSER_PASSWORD=${{ secrets.DJANGO_SUPERUSER_PASSWORD }}

            SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}

            ALLOWED_HOSTS=*
            DB_PROFILE=gcp
            DEBUG=False
            ENVIRONMENT=production

            CORS_ALLOWED_ORIGINS=*
            CSRF_TRUSTED_ORIGINS=https://*.run.app
            ADMIN_URL_PATH=${{ secrets.ADMIN_URL_PATH }}

      # ---------- Post-Deployment Health Check ----------
      - name: Wait for deployment to stabilize
        run: sleep 30

      - name: Health Check
        id: health_check
        run: |
          SERVICE_URL="${{ steps.deploy_cloudrun.outputs.url }}"
          echo "Checking health at: $SERVICE_URL/health/"

          # Check health endpoint (primary health check)
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$SERVICE_URL/health/" || echo "000")
          RESPONSE=$(curl -s "$SERVICE_URL/health/" || echo "{}")
          echo "Health Endpoint Response: $HTTP_CODE"
          echo "Response Body: $RESPONSE"

          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "::error::Health check failed: /health/ returned $HTTP_CODE"
            exit 1
          fi
          echo "[PASS] Health endpoint is responding correctly"

      - name: Smoke Test - API Endpoints
        run: |
          SERVICE_URL="${{ steps.deploy_cloudrun.outputs.url }}"

          echo "Running smoke tests..."

          # Test well-known endpoint
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$SERVICE_URL/.well-known/webauthn" || echo "000")
          echo "WebAuthn Well-Known: $HTTP_CODE"

          # Test API base
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$SERVICE_URL/api/" || echo "000")
          echo "API Base: $HTTP_CODE"

          echo "[PASS] Smoke tests completed"

      - name: Verify Cloud Run Service Status
        run: |
          echo "Verifying Cloud Run service..."
          
          # Get the latest revision info
          LATEST_REVISION=$(gcloud run revisions list --service=${{ env.SERVICE_NAME }} --region=${{ env.REGION }} --sort-by="~createTime" --limit=1 --format="value(metadata.name)")
          DEPLOYED_IMAGE=$(gcloud run revisions describe $LATEST_REVISION --region=${{ env.REGION }} --format="value(spec.containers[0].image)")
          
          echo "Latest revision: $LATEST_REVISION"
          echo "Deployed image: $DEPLOYED_IMAGE"
          echo "Expected image digest: ${{ steps.image.outputs.digest }}"
          
          # Verify the deployed image matches what we built
          if [[ "$DEPLOYED_IMAGE" != *"${{ steps.image.outputs.digest }}"* ]]; then
            echo "::warning::Deployed image does not contain expected digest!"
            echo "Expected: ${{ steps.image.outputs.image_ref }}"
            echo "Got: $DEPLOYED_IMAGE"
          else
            echo "[PASS] Deployed image matches expected digest"
          fi
          
          # Check traffic routing
          TRAFFIC=$(gcloud run services describe ${{ env.SERVICE_NAME }} --region=${{ env.REGION }} --format="value(status.traffic[0].percent)")
          echo "Traffic to latest revision: ${TRAFFIC}%"
          
          # Check if service is serving traffic
          SERVING=$(gcloud run services describe ${{ env.SERVICE_NAME }} --region=${{ env.REGION }} --format="value(status.conditions[0].status)")
          if [ "$SERVING" != "True" ]; then
            echo "::error::Service is not in healthy state"
            exit 1
          fi
          echo "[PASS] Cloud Run service is healthy"
          
          # Add to summary
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Cloud Run Deployment" >> $GITHUB_STEP_SUMMARY
          echo "**Latest Revision:** $LATEST_REVISION" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed Image:** $DEPLOYED_IMAGE" >> $GITHUB_STEP_SUMMARY
          echo "**Traffic:** ${TRAFFIC}%" >> $GITHUB_STEP_SUMMARY

      # Note: Deployment status is automatically updated by GitHub Actions based on job result
      # The job-level 'environment' setting handles deployment record creation and status updates

      # ---------- Rollback Logic ----------
      - name: Rollback on Failure
        if: failure()
        run: |-
          echo "Deployment failed, rolling back to previous revision..."
          LAST_REVISION=$(gcloud run revisions list --service=${{ env.SERVICE_NAME }} --region=${{ env.REGION }} --sort-by="~createTime" --limit=2 --format="value(metadata.name)" | tail -n 1)
          if [ -n "$LAST_REVISION" ]; then
            gcloud run services update-traffic ${{ env.SERVICE_NAME }} --region=${{ env.REGION }} --to-revisions=$LAST_REVISION=100
            echo "Rollback complete: now serving $LAST_REVISION"
          else
            echo "No previous revision found, skipping rollback."
          fi
