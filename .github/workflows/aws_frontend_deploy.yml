name: AWS Frontend Deploy

on:
  workflow_run:
    workflows: ["Frontend CI"]
    types: [completed]
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  deployments: write

concurrency:
  group: aws-frontend-${{ github.event.workflow_run.head_branch || github.ref }}
  cancel-in-progress: true

jobs:
  ci_gate:
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') }}
    runs-on: ubuntu-latest
    outputs:
      deploy_sha: ${{ steps.resolve.outputs.deploy_sha }}
    steps:
      - name: Validate CI gate
        id: resolve
        uses: actions/github-script@v7
        with:
          script: |
            const deploySha = context.payload.workflow_run?.head_sha || context.sha;

            if (context.eventName === "workflow_dispatch") {
              core.setOutput("deploy_sha", deploySha);
              return;
            }

            const runsResp = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head_sha: deploySha,
              per_page: 100
            });

            const backendRuns = runsResp.data.workflow_runs
              .filter((r) => r.name === "Backend CI")
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

            if (backendRuns.length === 0) {
              core.setFailed(`No Backend CI run found for commit ${deploySha}`);
              return;
            }

            const backendRun = backendRuns[0];
            if (backendRun.status !== "completed" || backendRun.conclusion !== "success") {
              core.setFailed(
                `Backend CI is not successful for ${deploySha}. ` +
                `status=${backendRun.status} conclusion=${backendRun.conclusion}`
              );
              return;
            }

            core.setOutput("deploy_sha", deploySha);

  guardrails:
    needs: [ci_gate]
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') }}
    uses: ./.github/workflows/aws_guardrails.yml
    secrets: inherit
    with:
      aws_region: ${{ vars.AWS_REGION || 'us-west-2' }}
      expected_account_id: ${{ vars.AWS_ACCOUNT_ID || '394167325273' }}
      resource_prefix: ${{ vars.AWS_RESOURCE_PREFIX || 'i2g-mobileid-' }}
      amplify_app_name: ${{ vars.AWS_FRONTEND_AMPLIFY_APP_NAME }}
      cloudfront_comment: ${{ vars.AWS_BACKEND_CLOUDFRONT_COMMENT }}
      resource_names: ${{ vars.AWS_FRONTEND_ARTIFACT_BUCKET }}

  deploy:
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') }}
    runs-on: ubuntu-latest
    needs: [ci_gate, guardrails]
    timeout-minutes: 35
    env:
      DEPLOY_SHA: ${{ needs.ci_gate.outputs.deploy_sha }}
      AWS_REGION: ${{ vars.AWS_REGION || 'us-west-2' }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
      AWS_FRONTEND_AMPLIFY_APP_ID: ${{ vars.AWS_FRONTEND_AMPLIFY_APP_ID }}
      AWS_FRONTEND_AMPLIFY_BRANCH: ${{ vars.AWS_FRONTEND_AMPLIFY_BRANCH || 'main' }}
      AWS_FRONTEND_ARTIFACT_BUCKET: ${{ secrets.AWS_FRONTEND_ARTIFACT_BUCKET || vars.AWS_FRONTEND_ARTIFACT_BUCKET }}
      AWS_FRONTEND_CUSTOM_DOMAIN_ROOT: ${{ vars.AWS_FRONTEND_CUSTOM_DOMAIN_ROOT }}
      AWS_FRONTEND_CUSTOM_SUBDOMAIN: ${{ vars.AWS_FRONTEND_CUSTOM_SUBDOMAIN }}
      AWS_FRONTEND_ROUTE53_ZONE_ID: ${{ vars.AWS_FRONTEND_ROUTE53_ZONE_ID }}
      VITE_API_BASE_URL: ${{ vars.VITE_API_BASE_URL_AWS }}
      VITE_API_BASE_URL_AWS: ${{ vars.VITE_API_BASE_URL_AWS }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ env.DEPLOY_SHA }}

      - name: Configure AWS credentials (session token)
        if: ${{ startsWith(env.AWS_ACCESS_KEY_ID, 'ASIA') && env.AWS_SESSION_TOKEN != '' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ env.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure AWS credentials (long-lived)
        if: ${{ !startsWith(env.AWS_ACCESS_KEY_ID, 'ASIA') || env.AWS_SESSION_TOKEN == '' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Validate required deployment inputs
        shell: bash
        run: |
          set -euo pipefail
          required=(
            AWS_FRONTEND_AMPLIFY_APP_ID
            AWS_FRONTEND_AMPLIFY_BRANCH
            AWS_FRONTEND_ARTIFACT_BUCKET
            AWS_FRONTEND_CUSTOM_DOMAIN_ROOT
            AWS_FRONTEND_CUSTOM_SUBDOMAIN
            AWS_FRONTEND_ROUTE53_ZONE_ID
            VITE_API_BASE_URL
          )
          for key in "${required[@]}"; do
            if [[ -z "${!key}" ]]; then
              echo "::error::Missing required env/secrets: $key"
              exit 1
            fi
          done

          if [[ "$VITE_API_BASE_URL" != https://* ]]; then
            echo "::error::VITE_API_BASE_URL must use https: $VITE_API_BASE_URL"
            exit 1
          fi

          if [[ "$VITE_API_BASE_URL" == *".elb.amazonaws.com"* ]]; then
            echo "::error::VITE_API_BASE_URL must not point to ALB directly: $VITE_API_BASE_URL"
            exit 1
          fi

          if [[ "$AWS_FRONTEND_CUSTOM_DOMAIN_ROOT" == http* ]]; then
            echo "::error::AWS_FRONTEND_CUSTOM_DOMAIN_ROOT must not include scheme: $AWS_FRONTEND_CUSTOM_DOMAIN_ROOT"
            exit 1
          fi

          if [[ "$AWS_FRONTEND_CUSTOM_SUBDOMAIN" == *"."* ]]; then
            echo "::error::AWS_FRONTEND_CUSTOM_SUBDOMAIN must be a prefix only (no dots): $AWS_FRONTEND_CUSTOM_SUBDOMAIN"
            exit 1
          fi

          echo "Frontend API base URL: $VITE_API_BASE_URL"
          echo "Frontend custom domain target: https://${AWS_FRONTEND_CUSTOM_SUBDOMAIN}.${AWS_FRONTEND_CUSTOM_DOMAIN_ROOT}"

      - name: Create GitHub deployment (frontend)
        id: gh_deployment
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          DEPLOY_SHA: ${{ env.DEPLOY_SHA }}
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: process.env.DEPLOY_SHA,
              task: "deploy",
              environment: "Mobile ID -Prod - AWS - Amplify",
              auto_merge: false,
              required_contexts: [],
              production_environment: true,
              transient_environment: false,
              description: `AWS Amplify frontend deploy run ${context.runId}`
            });
            core.setOutput("id", String(deployment.data.id));

      - name: Mark GitHub deployment in progress (frontend)
        if: ${{ steps.gh_deployment.outputs.id != '' }}
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          DEPLOYMENT_ID: ${{ steps.gh_deployment.outputs.id }}
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: Number(process.env.DEPLOYMENT_ID),
              state: "in_progress",
              log_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              description: "AWS frontend deployment is running"
            });

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "yarn"
          cache-dependency-path: pages/yarn.lock

      - name: Install dependencies
        working-directory: ./pages
        run: yarn install --frozen-lockfile --network-timeout 120000

      - name: Build frontend
        working-directory: ./pages
        run: yarn build

      - name: Verify bundled API base URL
        shell: bash
        run: |
          set -euo pipefail

          shopt -s nullglob
          files=(pages/dist/assets/index-*.js)
          if [[ ${#files[@]} -eq 0 ]]; then
            echo "::error::No built index bundles found under pages/dist/assets"
            exit 1
          fi

          if grep -R --line-number --fixed-strings ".elb.amazonaws.com" "${files[@]}" >/dev/null; then
            echo "::error::Built bundle contains ALB endpoint. Frontend must use CloudFront API URL."
            exit 1
          fi

          if ! grep -R --line-number --fixed-strings "$VITE_API_BASE_URL" "${files[@]}" >/dev/null; then
            echo "::error::Built bundle does not contain expected API base URL: $VITE_API_BASE_URL"
            exit 1
          fi

          echo "Verified bundled API base URL: $VITE_API_BASE_URL"

      - name: Package artifact
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p out
          cd pages/dist
          zip -qr ../../out/frontend-dist.zip .

      - name: Upload artifact to S3
        id: artifact
        shell: bash
        run: |
          set -euo pipefail
          KEY="frontend/${DEPLOY_SHA}/frontend-dist.zip"
          S3_URI="s3://${AWS_FRONTEND_ARTIFACT_BUCKET}/${KEY}"
          aws s3 cp out/frontend-dist.zip "${S3_URI}"
          SOURCE_URL="$(aws s3 presign "${S3_URI}" --expires-in 3600)"
          echo "source_url=${SOURCE_URL}" >> "$GITHUB_OUTPUT"

      - name: Ensure Amplify branch exists
        shell: bash
        run: |
          set -euo pipefail
          exists="$(aws amplify get-branch --app-id "$AWS_FRONTEND_AMPLIFY_APP_ID" --branch-name "$AWS_FRONTEND_AMPLIFY_BRANCH" --query 'branch.branchName' --output text 2>/dev/null || true)"
          if [[ -z "$exists" || "$exists" == "None" ]]; then
            aws amplify create-branch --app-id "$AWS_FRONTEND_AMPLIFY_APP_ID" --branch-name "$AWS_FRONTEND_AMPLIFY_BRANCH" >/dev/null
          fi

      - name: Ensure Amplify custom domain association + Route53 records
        id: custom_domain_setup
        shell: bash
        run: |
          set -euo pipefail

          custom_fqdn="${AWS_FRONTEND_CUSTOM_SUBDOMAIN}.${AWS_FRONTEND_CUSTOM_DOMAIN_ROOT}"
          root_domain="${AWS_FRONTEND_CUSTOM_DOMAIN_ROOT%.}"
          zone_id="${AWS_FRONTEND_ROUTE53_ZONE_ID##*/}"
          echo "custom_fqdn=${custom_fqdn}" >> "$GITHUB_OUTPUT"

          get_domain_assoc() {
            aws amplify get-domain-association \
              --app-id "$AWS_FRONTEND_AMPLIFY_APP_ID" \
              --domain-name "$AWS_FRONTEND_CUSTOM_DOMAIN_ROOT" \
              --output json 2>/dev/null || true
          }

          assoc_json="$(get_domain_assoc)"

          if [[ -z "$assoc_json" ]]; then
            sub_settings="$(jq -cn \
              --arg prefix "$AWS_FRONTEND_CUSTOM_SUBDOMAIN" \
              --arg branch "$AWS_FRONTEND_AMPLIFY_BRANCH" \
              '[{prefix:$prefix,branchName:$branch}]'
            )"
            echo "Creating Amplify domain association for ${AWS_FRONTEND_CUSTOM_DOMAIN_ROOT}"
            aws amplify create-domain-association \
              --app-id "$AWS_FRONTEND_AMPLIFY_APP_ID" \
              --domain-name "$AWS_FRONTEND_CUSTOM_DOMAIN_ROOT" \
              --sub-domain-settings "$sub_settings" >/dev/null
          else
            current_settings="$(jq -c \
              '[.domainAssociation.subDomains[]?.subDomainSetting | {prefix,branchName}] | sort_by(.prefix,.branchName)' \
              <<<"$assoc_json"
            )"

            merged_settings="$(jq -c \
              --arg prefix "$AWS_FRONTEND_CUSTOM_SUBDOMAIN" \
              --arg branch "$AWS_FRONTEND_AMPLIFY_BRANCH" \
              '
                (
                  [.domainAssociation.subDomains[]?.subDomainSetting
                    | {prefix,branchName}
                    | select(.prefix != $prefix)]
                  + [{"prefix":$prefix,"branchName":$branch}]
                )
                | sort_by(.prefix,.branchName)
              ' <<<"$assoc_json"
            )"

            if [[ "$current_settings" != "$merged_settings" ]]; then
              echo "Updating Amplify domain association subdomain mapping"

              max_attempts=30
              for attempt in $(seq 1 "$max_attempts"); do
                if update_output="$(aws amplify update-domain-association \
                  --app-id "$AWS_FRONTEND_AMPLIFY_APP_ID" \
                  --domain-name "$AWS_FRONTEND_CUSTOM_DOMAIN_ROOT" \
                  --sub-domain-settings "$merged_settings" \
                  --output json 2>&1)"; then
                  break
                fi

                if grep -qi "certificate is updating" <<<"$update_output"; then
                  if [[ "$attempt" -lt "$max_attempts" ]]; then
                    echo "::warning::Amplify certificate is updating; retrying update-domain-association (${attempt}/${max_attempts})"
                    sleep 20
                    continue
                  fi
                fi

                echo "::error::Unable to update Amplify domain association"
                echo "$update_output"
                exit 1
              done
            else
              echo "Amplify domain association already has desired subdomain mapping"
            fi
          fi

          assoc_json=""
          for i in {1..30}; do
            assoc_json="$(get_domain_assoc)"
            dns_count="$(jq '[.domainAssociation.certificateVerificationDNSRecord, (.domainAssociation.subDomains[]?.dnsRecord)] | map(select(. != null and . != "")) | length' <<<"$assoc_json" 2>/dev/null || echo "0")"
            if [[ "$dns_count" -gt 0 ]]; then
              break
            fi
            sleep 10
          done

          mapfile -t dns_records < <(
            jq -r '
              [
                .domainAssociation.certificateVerificationDNSRecord,
                (.domainAssociation.subDomains[]?.dnsRecord)
              ]
              | map(select(. != null and . != ""))
              | unique
              | .[]
            ' <<<"$assoc_json"
          )

          if [[ ${#dns_records[@]} -eq 0 ]]; then
            echo "::warning::No Amplify DNS records are available yet; skipping Route53 UPSERT for now."
            exit 0
          fi

          for rec in "${dns_records[@]}"; do
            parsed_json="$(
              python3 - "$rec" "$root_domain" <<'PY'
          import json
          import sys

          raw_record = sys.argv[1].strip()
          root = sys.argv[2].strip().rstrip(".").lower()

          parts = raw_record.split(None, 2)
          if len(parts) < 3:
              print(json.dumps({"ok": False, "record": raw_record, "reason": "unexpected format"}))
              raise SystemExit(0)

          name, rtype, value = parts[0].strip(), parts[1].strip().upper(), parts[2].strip()
          if not name or not rtype or not value:
              print(json.dumps({"ok": False, "record": raw_record, "reason": "missing token"}))
              raise SystemExit(0)

          name = name.rstrip(".")
          if name == "@":
              fqdn = root
          elif name.lower() == root or name.lower().endswith("." + root):
              fqdn = name
          else:
              fqdn = f"{name}.{root}"

          print(json.dumps({
              "ok": True,
              "name": fqdn.rstrip(".") + ".",
              "type": rtype,
              "value": value,
              "record": raw_record
          }))
          PY
            )"

            if [[ "$(jq -r '.ok' <<<"$parsed_json")" != "true" ]]; then
              reason="$(jq -r '.reason' <<<"$parsed_json")"
              bad_rec="$(jq -r '.record' <<<"$parsed_json")"
              echo "::warning::Skipping Amplify DNS record (${reason}): ${bad_rec}"
              continue
            fi

            name="$(jq -r '.name' <<<"$parsed_json")"
            rtype="$(jq -r '.type' <<<"$parsed_json")"
            value="$(jq -r '.value' <<<"$parsed_json")"

            echo "UPSERT Route53 record: ${name} ${rtype} ${value}"

            change_batch="$(jq -cn \
              --arg name "$name" \
              --arg type "$rtype" \
              --arg value "$value" \
              '{
                Changes: [
                  {
                    Action: "UPSERT",
                    ResourceRecordSet: {
                      Name: $name,
                      Type: $type,
                      TTL: 300,
                      ResourceRecords: [{Value: $value}]
                    }
                  }
                ]
              }'
            )"

            aws route53 change-resource-record-sets \
              --hosted-zone-id "$zone_id" \
              --change-batch "$change_batch" >/dev/null
          done

      - name: Resolve preferred frontend URL
        id: preferred_domain
        shell: bash
        run: |
          set -euo pipefail

          custom_fqdn="${{ steps.custom_domain_setup.outputs.custom_fqdn }}"
          default_domain="$(aws amplify get-app --app-id "$AWS_FRONTEND_AMPLIFY_APP_ID" --query 'app.defaultDomain' --output text)"
          default_url="https://${AWS_FRONTEND_AMPLIFY_BRANCH}.${default_domain}"
          preferred_url="$default_url"
          available="false"

          for i in {1..120}; do
            status="$(aws amplify get-domain-association \
              --app-id "$AWS_FRONTEND_AMPLIFY_APP_ID" \
              --domain-name "$AWS_FRONTEND_CUSTOM_DOMAIN_ROOT" \
              --query 'domainAssociation.domainStatus' \
              --output text 2>/dev/null || true)"

            if [[ "$status" == "AVAILABLE" ]]; then
              preferred_url="https://${custom_fqdn}"
              available="true"
              break
            fi
            sleep 10
          done

          if [[ "$available" != "true" ]]; then
            echo "::warning::Custom domain is not AVAILABLE yet. Falling back to ${default_url} for this deployment run."
          fi

          echo "custom_domain_available=${available}" >> "$GITHUB_OUTPUT"
          echo "url=${preferred_url}" >> "$GITHUB_OUTPUT"
          echo "Frontend preferred URL: ${preferred_url}"

      - name: Start Amplify deployment
        id: deploy
        shell: bash
        run: |
          set -euo pipefail
          JOB_ID="$(aws amplify start-deployment \
            --app-id "$AWS_FRONTEND_AMPLIFY_APP_ID" \
            --branch-name "$AWS_FRONTEND_AMPLIFY_BRANCH" \
            --source-url "${{ steps.artifact.outputs.source_url }}" \
            --query 'jobSummary.jobId' \
            --output text)"

          echo "job_id=${JOB_ID}" >> "$GITHUB_OUTPUT"

      - name: Wait for Amplify deployment
        shell: bash
        run: |
          set -euo pipefail
          JOB_ID="${{ steps.deploy.outputs.job_id }}"

          for i in {1..90}; do
            STATUS="$(aws amplify get-job \
              --app-id "$AWS_FRONTEND_AMPLIFY_APP_ID" \
              --branch-name "$AWS_FRONTEND_AMPLIFY_BRANCH" \
              --job-id "$JOB_ID" \
              --query 'job.summary.status' \
              --output text)"

            case "$STATUS" in
              SUCCEED)
                echo "Amplify deployment succeeded"
                exit 0
                ;;
              FAILED|CANCELLED)
                echo "::error::Amplify deployment failed: $STATUS"
                aws amplify get-job --app-id "$AWS_FRONTEND_AMPLIFY_APP_ID" --branch-name "$AWS_FRONTEND_AMPLIFY_BRANCH" --job-id "$JOB_ID"
                exit 1
                ;;
              *)
                sleep 10
                ;;
            esac
          done

          echo "::error::Amplify deployment timed out"
          exit 1

      - name: Smoke test
        id: smoke
        shell: bash
        run: |
          set -euo pipefail
          url="${{ steps.preferred_domain.outputs.url }}"
          if [[ -z "$url" ]]; then
            domain="$(aws amplify get-app --app-id "$AWS_FRONTEND_AMPLIFY_APP_ID" --query 'app.defaultDomain' --output text)"
            url="https://${AWS_FRONTEND_AMPLIFY_BRANCH}.${domain}"
          fi

          for i in {1..24}; do
            code="$(curl -s -o /dev/null -w '%{http_code}' "$url" || true)"
            if [[ "$code" -ge 200 && "$code" -lt 400 ]]; then
              echo "Frontend smoke test passed: $url"
              echo "url=${url}" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            sleep 5
          done

          echo "::error::Frontend smoke test failed: $url"
          exit 1

      - name: Mark GitHub deployment success (frontend)
        if: ${{ success() && steps.gh_deployment.outputs.id != '' }}
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          DEPLOYMENT_ID: ${{ steps.gh_deployment.outputs.id }}
          DEPLOYMENT_URL: ${{ steps.smoke.outputs.url }}
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: Number(process.env.DEPLOYMENT_ID),
              state: "success",
              log_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              environment_url: process.env.DEPLOYMENT_URL || undefined,
              auto_inactive: false,
              description: "AWS frontend deployment succeeded"
            });

      - name: Mark GitHub deployment failure (frontend)
        if: ${{ failure() && steps.gh_deployment.outputs.id != '' }}
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          DEPLOYMENT_ID: ${{ steps.gh_deployment.outputs.id }}
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: Number(process.env.DEPLOYMENT_ID),
              state: "failure",
              log_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              description: "AWS frontend deployment failed"
            });

      - name: Mark GitHub deployment cancelled (frontend)
        if: ${{ cancelled() && steps.gh_deployment.outputs.id != '' }}
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          DEPLOYMENT_ID: ${{ steps.gh_deployment.outputs.id }}
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: Number(process.env.DEPLOYMENT_ID),
              state: "inactive",
              log_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              description: "AWS frontend deployment cancelled"
            });
