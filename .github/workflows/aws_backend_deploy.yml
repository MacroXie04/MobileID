name: AWS Backend Deploy

on:
  push:
    branches: [main]
    paths:
      - "src/**"
      - ".github/workflows/aws_backend_deploy.yml"
      - ".github/workflows/aws_guardrails.yml"
  workflow_dispatch:

permissions:
  contents: read
  deployments: write

concurrency:
  group: aws-backend-${{ github.ref }}
  cancel-in-progress: true

jobs:
  guardrails:
    uses: ./.github/workflows/aws_guardrails.yml
    secrets: inherit
    with:
      aws_region: ${{ vars.AWS_REGION || 'us-west-2' }}
      expected_account_id: ${{ vars.AWS_ACCOUNT_ID || '394167325273' }}
      resource_prefix: ${{ vars.AWS_RESOURCE_PREFIX || 'i2g-mobileid-' }}
      ecr_repository: ${{ vars.AWS_ECR_REPOSITORY }}
      ecs_cluster: ${{ vars.AWS_ECS_CLUSTER }}
      ecs_service: ${{ vars.AWS_ECS_SERVICE }}
      ecs_task_family: ${{ vars.AWS_ECS_TASK_FAMILY }}
      alb_name: ${{ vars.AWS_ALB_NAME }}
      target_group_name: ${{ vars.AWS_TARGET_GROUP_NAME }}
      rds_instance: ${{ vars.AWS_RDS_INSTANCE }}
      vpc_name: ${{ vars.AWS_VPC_NAME }}
      cloudfront_comment: ${{ vars.AWS_BACKEND_CLOUDFRONT_COMMENT }}

  deploy:
    runs-on: ubuntu-latest
    needs: [guardrails]
    timeout-minutes: 45
    env:
      AWS_REGION: ${{ vars.AWS_REGION || 'us-west-2' }}
      AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID || '394167325273' }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
      AWS_ECR_REPOSITORY: ${{ vars.AWS_ECR_REPOSITORY }}
      AWS_ECS_CLUSTER: ${{ vars.AWS_ECS_CLUSTER }}
      AWS_ECS_SERVICE: ${{ vars.AWS_ECS_SERVICE }}
      AWS_ECS_TASK_FAMILY: ${{ vars.AWS_ECS_TASK_FAMILY }}
      AWS_ECS_CONTAINER_NAME: ${{ vars.AWS_ECS_CONTAINER_NAME }}
      AWS_ECS_SUBNET_IDS: ${{ secrets.AWS_ECS_SUBNET_IDS || vars.AWS_ECS_SUBNET_IDS }}
      AWS_ECS_SECURITY_GROUP_ID: ${{ secrets.AWS_ECS_SECURITY_GROUP_ID || vars.AWS_ECS_SECURITY_GROUP_ID }}
      AWS_ECS_EXECUTION_ROLE_ARN: ${{ secrets.AWS_ECS_EXECUTION_ROLE_ARN || vars.AWS_ECS_EXECUTION_ROLE_ARN }}
      AWS_ECS_TASK_ROLE_ARN: ${{ secrets.AWS_ECS_TASK_ROLE_ARN || vars.AWS_ECS_TASK_ROLE_ARN }}
      AWS_ECS_TARGET_GROUP_ARN: ${{ secrets.AWS_ECS_TARGET_GROUP_ARN || vars.AWS_ECS_TARGET_GROUP_ARN }}
      AWS_DB_SECRET_ARN: ${{ secrets.AWS_DB_SECRET_ARN || vars.AWS_DB_SECRET_ARN }}
      AWS_APP_SECRET_ARN: ${{ secrets.AWS_APP_SECRET_ARN || vars.AWS_APP_SECRET_ARN }}
      AWS_ALB_NAME: ${{ vars.AWS_ALB_NAME }}
      AWS_BACKEND_HEALTHCHECK_URL: ${{ vars.AWS_BACKEND_HEALTHCHECK_URL }}
      # Username/email are configured in repository variables; password stays in secrets.
      GH_DJANGO_SUPERUSER_USERNAME: ${{ vars.DJANGO_SUPERUSER_USERNAME || secrets.DJANGO_SUPERUSER_USERNAME }}
      GH_DJANGO_SUPERUSER_EMAIL: ${{ vars.DJANGO_SUPERUSER_EMAIL || secrets.DJANGO_SUPERUSER_EMAIL }}
      GH_DJANGO_SUPERUSER_PASSWORD: ${{ secrets.DJANGO_SUPERUSER_PASSWORD }}
      GH_ADMIN_URL_PATH: ${{ secrets.ADMIN_URL_PATH }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (session token)
        if: ${{ env.AWS_SESSION_TOKEN != '' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ env.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure AWS credentials (long-lived)
        if: ${{ env.AWS_SESSION_TOKEN == '' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Validate required deployment inputs
        shell: bash
        run: |
          set -euo pipefail
          required=(
            AWS_ECR_REPOSITORY
            AWS_ECS_CLUSTER
            AWS_ECS_SERVICE
            AWS_ECS_TASK_FAMILY
            AWS_ECS_SUBNET_IDS
            AWS_ECS_SECURITY_GROUP_ID
            AWS_ECS_EXECUTION_ROLE_ARN
            AWS_ECS_TASK_ROLE_ARN
            AWS_ECS_TARGET_GROUP_ARN
            AWS_DB_SECRET_ARN
            AWS_APP_SECRET_ARN
            AWS_ALB_NAME
            GH_DJANGO_SUPERUSER_USERNAME
            GH_DJANGO_SUPERUSER_EMAIL
            GH_DJANGO_SUPERUSER_PASSWORD
          )
          for key in "${required[@]}"; do
            if [[ -z "${!key}" ]]; then
              echo "::error::Missing required env/secrets: $key"
              exit 1
            fi
          done

      - name: Create GitHub deployment (backend)
        id: gh_deployment
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              task: "deploy",
              environment: "i2g-MobileID-backend",
              auto_merge: false,
              required_contexts: [],
              production_environment: true,
              transient_environment: false,
              description: `AWS backend deploy run ${context.runId}`
            });
            core.setOutput("id", String(deployment.data.id));

      - name: Mark GitHub deployment in progress (backend)
        if: ${{ steps.gh_deployment.outputs.id != '' }}
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          DEPLOYMENT_ID: ${{ steps.gh_deployment.outputs.id }}
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: Number(process.env.DEPLOYMENT_ID),
              state: "in_progress",
              log_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              description: "AWS backend deployment is running"
            });

      - name: Sync Django admin bootstrap secrets to AWS app secret
        shell: bash
        run: |
          set -euo pipefail

          current_secret="$(aws secretsmanager get-secret-value \
            --secret-id "$AWS_APP_SECRET_ARN" \
            --query 'SecretString' \
            --output text)"

          if [[ -z "$current_secret" || "$current_secret" == "None" ]]; then
            echo "::error::AWS app secret is empty: $AWS_APP_SECRET_ARN"
            exit 1
          fi

          updated_secret="$(
            jq -c \
              --arg su "$GH_DJANGO_SUPERUSER_USERNAME" \
              --arg em "$GH_DJANGO_SUPERUSER_EMAIL" \
              --arg pw "$GH_DJANGO_SUPERUSER_PASSWORD" \
              --arg ap "$GH_ADMIN_URL_PATH" \
              '
                .DJANGO_SUPERUSER_USERNAME = $su
                | .DJANGO_SUPERUSER_EMAIL = $em
                | .DJANGO_SUPERUSER_PASSWORD = $pw
                | if ($ap | length) > 0 then .ADMIN_URL_PATH = $ap else . end
              ' <<<"$current_secret"
          )"

          aws secretsmanager put-secret-value \
            --secret-id "$AWS_APP_SECRET_ARN" \
            --secret-string "$updated_secret" >/dev/null

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push backend image
        id: build
        shell: bash
        run: |
          set -euo pipefail
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${AWS_ECR_REPOSITORY}"
          IMAGE_TAG="${GITHUB_SHA}"

          docker buildx build \
            --platform linux/amd64 \
            --file src/Dockerfile \
            --tag "${ECR_URI}:${IMAGE_TAG}" \
            --tag "${ECR_URI}:latest" \
            --push \
            src

          echo "ecr_uri=${ECR_URI}" >> "$GITHUB_OUTPUT"
          echo "image_tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"

      - name: Render task definition
        id: taskdef
        shell: bash
        run: |
          set -euo pipefail

          IMAGE="${{ steps.build.outputs.ecr_uri }}:${{ steps.build.outputs.image_tag }}"
          LOG_GROUP="/ecs/i2g-mobileid-api"

          cat > task-def.json <<EOF
          {
            "family": "${AWS_ECS_TASK_FAMILY}",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "256",
            "memory": "512",
            "executionRoleArn": "${AWS_ECS_EXECUTION_ROLE_ARN}",
            "taskRoleArn": "${AWS_ECS_TASK_ROLE_ARN}",
            "containerDefinitions": [
              {
                "name": "${AWS_ECS_CONTAINER_NAME}",
                "image": "${IMAGE}",
                "essential": true,
                "portMappings": [
                  {
                    "containerPort": 8080,
                    "protocol": "tcp"
                  }
                ],
                "environment": [
                  {"name": "DJANGO_SETTINGS_MODULE", "value": "core.settings.prod"},
                  {"name": "DB_PROFILE", "value": "aws"},
                  {"name": "DB_SSL_MODE", "value": "require"},
                  {"name": "SECURE_SSL_REDIRECT", "value": "False"},
                  {"name": "DEBUG", "value": "False"},
                  {"name": "ENVIRONMENT", "value": "production"}
                ],
                "secrets": [
                  {"name": "DATABASE_URL_AWS", "valueFrom": "${AWS_DB_SECRET_ARN}:DATABASE_URL_AWS::"},
                  {"name": "SECRET_KEY", "valueFrom": "${AWS_APP_SECRET_ARN}:SECRET_KEY::"},
                  {"name": "ALLOWED_HOSTS", "valueFrom": "${AWS_APP_SECRET_ARN}:ALLOWED_HOSTS::"},
                  {"name": "CORS_ALLOWED_ORIGINS", "valueFrom": "${AWS_APP_SECRET_ARN}:CORS_ALLOWED_ORIGINS::"},
                  {"name": "CSRF_TRUSTED_ORIGINS", "valueFrom": "${AWS_APP_SECRET_ARN}:CSRF_TRUSTED_ORIGINS::"},
                  {"name": "ADMIN_URL_PATH", "valueFrom": "${AWS_APP_SECRET_ARN}:ADMIN_URL_PATH::"},
                  {"name": "DJANGO_SUPERUSER_USERNAME", "valueFrom": "${AWS_APP_SECRET_ARN}:DJANGO_SUPERUSER_USERNAME::"},
                  {"name": "DJANGO_SUPERUSER_EMAIL", "valueFrom": "${AWS_APP_SECRET_ARN}:DJANGO_SUPERUSER_EMAIL::"},
                  {"name": "DJANGO_SUPERUSER_PASSWORD", "valueFrom": "${AWS_APP_SECRET_ARN}:DJANGO_SUPERUSER_PASSWORD::"}
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "${LOG_GROUP}",
                    "awslogs-region": "${AWS_REGION}",
                    "awslogs-stream-prefix": "ecs"
                  }
                }
              }
            ]
          }
          EOF

          TASK_DEF_ARN="$(aws ecs register-task-definition --cli-input-json file://task-def.json --query 'taskDefinition.taskDefinitionArn' --output text)"
          echo "task_def_arn=${TASK_DEF_ARN}" >> "$GITHUB_OUTPUT"

      - name: Run database migrations as one-off task
        shell: bash
        run: |
          set -euo pipefail

          SUBNETS="$(echo "$AWS_ECS_SUBNET_IDS" | sed 's/,/\,/g')"
          NETWORK_CONFIG="awsvpcConfiguration={subnets=[${SUBNETS}],securityGroups=[${AWS_ECS_SECURITY_GROUP_ID}],assignPublicIp=ENABLED}"

          TASK_ARN="$(aws ecs run-task \
            --cluster "$AWS_ECS_CLUSTER" \
            --launch-type FARGATE \
            --task-definition "${{ steps.taskdef.outputs.task_def_arn }}" \
            --network-configuration "$NETWORK_CONFIG" \
            --overrides "{\"containerOverrides\":[{\"name\":\"$AWS_ECS_CONTAINER_NAME\",\"command\":[\"uv\",\"run\",\"python\",\"manage.py\",\"migrate\",\"--noinput\"]}]}" \
            --query 'tasks[0].taskArn' \
            --output text)"

          if [[ -z "$TASK_ARN" || "$TASK_ARN" == "None" ]]; then
            echo "::error::Failed to start migration task"
            exit 1
          fi

          echo "Started migration task: $TASK_ARN"

          for i in {1..120}; do
            STATUS="$(aws ecs describe-tasks --cluster "$AWS_ECS_CLUSTER" --tasks "$TASK_ARN" --query 'tasks[0].lastStatus' --output text)"
            if [[ "$STATUS" == "STOPPED" ]]; then
              break
            fi
            sleep 5
          done

          EXIT_CODE="$(aws ecs describe-tasks --cluster "$AWS_ECS_CLUSTER" --tasks "$TASK_ARN" --query 'tasks[0].containers[0].exitCode' --output text)"
          if [[ "$EXIT_CODE" != "0" ]]; then
            echo "::error::Migration task failed with exit code $EXIT_CODE"
            aws ecs describe-tasks --cluster "$AWS_ECS_CLUSTER" --tasks "$TASK_ARN"
            exit 1
          fi

      - name: Create/update Django admin as one-off task
        shell: bash
        run: |
          set -euo pipefail

          SUBNETS="$(echo "$AWS_ECS_SUBNET_IDS" | sed 's/,/\,/g')"
          NETWORK_CONFIG="awsvpcConfiguration={subnets=[${SUBNETS}],securityGroups=[${AWS_ECS_SECURITY_GROUP_ID}],assignPublicIp=ENABLED}"

          TASK_ARN="$(aws ecs run-task \
            --cluster "$AWS_ECS_CLUSTER" \
            --launch-type FARGATE \
            --task-definition "${{ steps.taskdef.outputs.task_def_arn }}" \
            --network-configuration "$NETWORK_CONFIG" \
            --overrides "{\"containerOverrides\":[{\"name\":\"$AWS_ECS_CONTAINER_NAME\",\"command\":[\"uv\",\"run\",\"python\",\"manage.py\",\"initadmin\"]}]}" \
            --query 'tasks[0].taskArn' \
            --output text)"

          if [[ -z "$TASK_ARN" || "$TASK_ARN" == "None" ]]; then
            echo "::error::Failed to start initadmin task"
            exit 1
          fi

          echo "Started initadmin task: $TASK_ARN"

          for i in {1..120}; do
            STATUS="$(aws ecs describe-tasks --cluster "$AWS_ECS_CLUSTER" --tasks "$TASK_ARN" --query 'tasks[0].lastStatus' --output text)"
            if [[ "$STATUS" == "STOPPED" ]]; then
              break
            fi
            sleep 5
          done

          EXIT_CODE="$(aws ecs describe-tasks --cluster "$AWS_ECS_CLUSTER" --tasks "$TASK_ARN" --query 'tasks[0].containers[0].exitCode' --output text)"
          if [[ "$EXIT_CODE" != "0" ]]; then
            echo "::error::Initadmin task failed with exit code $EXIT_CODE"
            aws ecs describe-tasks --cluster "$AWS_ECS_CLUSTER" --tasks "$TASK_ARN"
            exit 1
          fi

      - name: Create or update ECS service
        shell: bash
        run: |
          set -euo pipefail

          SUBNETS="$(echo "$AWS_ECS_SUBNET_IDS" | sed 's/,/\,/g')"
          NETWORK_CONFIG="awsvpcConfiguration={subnets=[${SUBNETS}],securityGroups=[${AWS_ECS_SECURITY_GROUP_ID}],assignPublicIp=ENABLED}"

          SERVICE_STATUS="$(aws ecs describe-services --cluster "$AWS_ECS_CLUSTER" --services "$AWS_ECS_SERVICE" --query 'services[0].status' --output text 2>/dev/null || true)"

          if [[ "$SERVICE_STATUS" == "ACTIVE" || "$SERVICE_STATUS" == "DRAINING" ]]; then
            aws ecs update-service \
              --cluster "$AWS_ECS_CLUSTER" \
              --service "$AWS_ECS_SERVICE" \
              --task-definition "${{ steps.taskdef.outputs.task_def_arn }}" \
              --force-new-deployment \
              --desired-count 1 >/dev/null
          else
            aws ecs create-service \
              --cluster "$AWS_ECS_CLUSTER" \
              --service-name "$AWS_ECS_SERVICE" \
              --task-definition "${{ steps.taskdef.outputs.task_def_arn }}" \
              --desired-count 1 \
              --launch-type FARGATE \
              --network-configuration "$NETWORK_CONFIG" \
              --load-balancers "targetGroupArn=${AWS_ECS_TARGET_GROUP_ARN},containerName=${AWS_ECS_CONTAINER_NAME},containerPort=8080" >/dev/null
          fi

      - name: Wait for ECS service stable
        shell: bash
        run: |
          set -euo pipefail
          aws ecs wait services-stable --cluster "$AWS_ECS_CLUSTER" --services "$AWS_ECS_SERVICE"

      - name: Health check
        id: health
        shell: bash
        run: |
          set -euo pipefail

          URL="$AWS_BACKEND_HEALTHCHECK_URL"
          if [[ -z "$URL" ]]; then
            ALB_DNS="$(aws elbv2 describe-load-balancers --names "$AWS_ALB_NAME" --query 'LoadBalancers[0].DNSName' --output text)"
            URL="http://${ALB_DNS}"
          fi

          echo "Health check base URL: $URL"
          for i in {1..24}; do
            code="$(curl -s -o /dev/null -w "%{http_code}" "${URL}/health/" || true)"
            if [[ "$code" == "200" ]]; then
              echo "Health check passed"
              echo "url=${URL}" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            sleep 5
          done

          echo "::error::Health check failed for ${URL}/health/"
          exit 1

      - name: Mark GitHub deployment success (backend)
        if: ${{ success() && steps.gh_deployment.outputs.id != '' }}
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          DEPLOYMENT_ID: ${{ steps.gh_deployment.outputs.id }}
          DEPLOYMENT_URL: ${{ steps.health.outputs.url }}
        with:
          script: |
            const baseUrl = (process.env.DEPLOYMENT_URL || "").replace(/\/$/, "");
            const environmentUrl = baseUrl ? `${baseUrl}/health/` : undefined;

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: Number(process.env.DEPLOYMENT_ID),
              state: "success",
              log_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              environment_url: environmentUrl,
              auto_inactive: false,
              description: "AWS backend deployment succeeded"
            });

      - name: Mark GitHub deployment failure (backend)
        if: ${{ failure() && steps.gh_deployment.outputs.id != '' }}
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          DEPLOYMENT_ID: ${{ steps.gh_deployment.outputs.id }}
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: Number(process.env.DEPLOYMENT_ID),
              state: "failure",
              log_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              description: "AWS backend deployment failed"
            });

      - name: Mark GitHub deployment cancelled (backend)
        if: ${{ cancelled() && steps.gh_deployment.outputs.id != '' }}
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          DEPLOYMENT_ID: ${{ steps.gh_deployment.outputs.id }}
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: Number(process.env.DEPLOYMENT_ID),
              state: "inactive",
              log_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              description: "AWS backend deployment cancelled"
            });
