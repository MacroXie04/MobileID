name: AWS Backend Deploy

on:
  push:
    branches: [main]
    paths:
      - "src/**"
      - ".github/workflows/aws_backend_deploy.yml"
      - ".github/workflows/aws_guardrails.yml"
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: aws-backend-${{ github.ref }}
  cancel-in-progress: true

jobs:
  guardrails:
    uses: ./.github/workflows/aws_guardrails.yml
    secrets: inherit
    with:
      aws_region: us-west-2
      expected_account_id: "394167325273"
      resource_prefix: i2g-mobileid-
      ecr_repository: i2g-mobileid-backend
      ecs_cluster: i2g-mobileid-cluster
      ecs_service: i2g-mobileid-api-svc
      ecs_task_family: i2g-mobileid-api
      alb_name: i2g-mobileid-alb
      target_group_name: i2g-mobileid-tg
      rds_instance: i2g-mobileid-mysql
      vpc_name: i2g-mobileid-vpc
      cloudfront_comment: i2g-MobileID-backend-api

  deploy:
    runs-on: ubuntu-latest
    needs: [guardrails]
    timeout-minutes: 45
    env:
      AWS_REGION: us-west-2
      AWS_ACCOUNT_ID: "394167325273"
      AWS_ECR_REPOSITORY: i2g-mobileid-backend
      AWS_ECS_CLUSTER: i2g-mobileid-cluster
      AWS_ECS_SERVICE: i2g-mobileid-api-svc
      AWS_ECS_TASK_FAMILY: i2g-mobileid-api
      AWS_ECS_CONTAINER_NAME: i2g-mobileid-api
      AWS_ECS_SUBNET_IDS: subnet-04bf3bb29364839f7,subnet-003d4470459623d70
      AWS_ECS_SECURITY_GROUP_ID: sg-0030a21952b22bf3e
      AWS_ECS_EXECUTION_ROLE_ARN: arn:aws:iam::394167325273:role/i2g-mobileid-ecs-execution-role
      AWS_ECS_TASK_ROLE_ARN: arn:aws:iam::394167325273:role/i2g-mobileid-ecs-task-role
      AWS_ECS_TARGET_GROUP_ARN: arn:aws:elasticloadbalancing:us-west-2:394167325273:targetgroup/i2g-mobileid-tg/b02954bd6df2f805
      AWS_DB_SECRET_ARN: arn:aws:secretsmanager:us-west-2:394167325273:secret:i2g-mobileid/db-RwZqhF
      AWS_APP_SECRET_ARN: arn:aws:secretsmanager:us-west-2:394167325273:secret:i2g-mobileid/app-OvoT3H
      AWS_ALB_NAME: i2g-mobileid-alb
      AWS_BACKEND_HEALTHCHECK_URL: https://d3c92y3ydsav7u.cloudfront.net

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (session token)
        if: ${{ secrets.AWS_SESSION_TOKEN != '' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure AWS credentials (long-lived)
        if: ${{ secrets.AWS_SESSION_TOKEN == '' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Validate required deployment inputs
        shell: bash
        run: |
          set -euo pipefail
          required=(
            AWS_ECR_REPOSITORY
            AWS_ECS_CLUSTER
            AWS_ECS_SERVICE
            AWS_ECS_TASK_FAMILY
            AWS_ECS_SUBNET_IDS
            AWS_ECS_SECURITY_GROUP_ID
            AWS_ECS_EXECUTION_ROLE_ARN
            AWS_ECS_TASK_ROLE_ARN
            AWS_ECS_TARGET_GROUP_ARN
            AWS_DB_SECRET_ARN
            AWS_APP_SECRET_ARN
            AWS_ALB_NAME
          )
          for key in "${required[@]}"; do
            if [[ -z "${!key}" ]]; then
              echo "::error::Missing required env/secrets: $key"
              exit 1
            fi
          done

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push backend image
        id: build
        shell: bash
        run: |
          set -euo pipefail
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${AWS_ECR_REPOSITORY}"
          IMAGE_TAG="${GITHUB_SHA}"

          docker buildx build \
            --platform linux/amd64 \
            --file src/Dockerfile \
            --tag "${ECR_URI}:${IMAGE_TAG}" \
            --tag "${ECR_URI}:latest" \
            --push \
            src

          echo "ecr_uri=${ECR_URI}" >> "$GITHUB_OUTPUT"
          echo "image_tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"

      - name: Render task definition
        id: taskdef
        shell: bash
        run: |
          set -euo pipefail

          IMAGE="${{ steps.build.outputs.ecr_uri }}:${{ steps.build.outputs.image_tag }}"
          LOG_GROUP="/ecs/i2g-mobileid-api"

          cat > task-def.json <<EOF
          {
            "family": "${AWS_ECS_TASK_FAMILY}",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "256",
            "memory": "512",
            "executionRoleArn": "${AWS_ECS_EXECUTION_ROLE_ARN}",
            "taskRoleArn": "${AWS_ECS_TASK_ROLE_ARN}",
            "containerDefinitions": [
              {
                "name": "${AWS_ECS_CONTAINER_NAME}",
                "image": "${IMAGE}",
                "essential": true,
                "portMappings": [
                  {
                    "containerPort": 8080,
                    "protocol": "tcp"
                  }
                ],
                "environment": [
                  {"name": "DJANGO_SETTINGS_MODULE", "value": "core.settings.prod"},
                  {"name": "DB_PROFILE", "value": "aws"},
                  {"name": "DB_SSL_MODE", "value": "require"},
                  {"name": "DEBUG", "value": "False"},
                  {"name": "ENVIRONMENT", "value": "production"}
                ],
                "secrets": [
                  {"name": "DATABASE_URL_AWS", "valueFrom": "${AWS_DB_SECRET_ARN}:DATABASE_URL_AWS::"},
                  {"name": "SECRET_KEY", "valueFrom": "${AWS_APP_SECRET_ARN}:SECRET_KEY::"},
                  {"name": "ALLOWED_HOSTS", "valueFrom": "${AWS_APP_SECRET_ARN}:ALLOWED_HOSTS::"},
                  {"name": "CORS_ALLOWED_ORIGINS", "valueFrom": "${AWS_APP_SECRET_ARN}:CORS_ALLOWED_ORIGINS::"},
                  {"name": "CSRF_TRUSTED_ORIGINS", "valueFrom": "${AWS_APP_SECRET_ARN}:CSRF_TRUSTED_ORIGINS::"},
                  {"name": "ADMIN_URL_PATH", "valueFrom": "${AWS_APP_SECRET_ARN}:ADMIN_URL_PATH::"},
                  {"name": "DJANGO_SUPERUSER_USERNAME", "valueFrom": "${AWS_APP_SECRET_ARN}:DJANGO_SUPERUSER_USERNAME::"},
                  {"name": "DJANGO_SUPERUSER_EMAIL", "valueFrom": "${AWS_APP_SECRET_ARN}:DJANGO_SUPERUSER_EMAIL::"},
                  {"name": "DJANGO_SUPERUSER_PASSWORD", "valueFrom": "${AWS_APP_SECRET_ARN}:DJANGO_SUPERUSER_PASSWORD::"}
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "${LOG_GROUP}",
                    "awslogs-region": "${AWS_REGION}",
                    "awslogs-stream-prefix": "ecs"
                  }
                }
              }
            ]
          }
          EOF

          TASK_DEF_ARN="$(aws ecs register-task-definition --cli-input-json file://task-def.json --query 'taskDefinition.taskDefinitionArn' --output text)"
          echo "task_def_arn=${TASK_DEF_ARN}" >> "$GITHUB_OUTPUT"

      - name: Run database migrations as one-off task
        shell: bash
        run: |
          set -euo pipefail

          SUBNETS="$(echo "$AWS_ECS_SUBNET_IDS" | sed 's/,/\,/g')"
          NETWORK_CONFIG="awsvpcConfiguration={subnets=[${SUBNETS}],securityGroups=[${AWS_ECS_SECURITY_GROUP_ID}],assignPublicIp=ENABLED}"

          TASK_ARN="$(aws ecs run-task \
            --cluster "$AWS_ECS_CLUSTER" \
            --launch-type FARGATE \
            --task-definition "${{ steps.taskdef.outputs.task_def_arn }}" \
            --network-configuration "$NETWORK_CONFIG" \
            --overrides "{\"containerOverrides\":[{\"name\":\"$AWS_ECS_CONTAINER_NAME\",\"command\":[\"uv\",\"run\",\"python\",\"manage.py\",\"migrate\",\"--noinput\"]}]}" \
            --query 'tasks[0].taskArn' \
            --output text)"

          if [[ -z "$TASK_ARN" || "$TASK_ARN" == "None" ]]; then
            echo "::error::Failed to start migration task"
            exit 1
          fi

          echo "Started migration task: $TASK_ARN"

          for i in {1..120}; do
            STATUS="$(aws ecs describe-tasks --cluster "$AWS_ECS_CLUSTER" --tasks "$TASK_ARN" --query 'tasks[0].lastStatus' --output text)"
            if [[ "$STATUS" == "STOPPED" ]]; then
              break
            fi
            sleep 5
          done

          EXIT_CODE="$(aws ecs describe-tasks --cluster "$AWS_ECS_CLUSTER" --tasks "$TASK_ARN" --query 'tasks[0].containers[0].exitCode' --output text)"
          if [[ "$EXIT_CODE" != "0" ]]; then
            echo "::error::Migration task failed with exit code $EXIT_CODE"
            aws ecs describe-tasks --cluster "$AWS_ECS_CLUSTER" --tasks "$TASK_ARN"
            exit 1
          fi

      - name: Create or update ECS service
        shell: bash
        run: |
          set -euo pipefail

          SUBNETS="$(echo "$AWS_ECS_SUBNET_IDS" | sed 's/,/\,/g')"
          NETWORK_CONFIG="awsvpcConfiguration={subnets=[${SUBNETS}],securityGroups=[${AWS_ECS_SECURITY_GROUP_ID}],assignPublicIp=ENABLED}"

          SERVICE_STATUS="$(aws ecs describe-services --cluster "$AWS_ECS_CLUSTER" --services "$AWS_ECS_SERVICE" --query 'services[0].status' --output text 2>/dev/null || true)"

          if [[ "$SERVICE_STATUS" == "ACTIVE" || "$SERVICE_STATUS" == "DRAINING" ]]; then
            aws ecs update-service \
              --cluster "$AWS_ECS_CLUSTER" \
              --service "$AWS_ECS_SERVICE" \
              --task-definition "${{ steps.taskdef.outputs.task_def_arn }}" \
              --force-new-deployment \
              --desired-count 1 >/dev/null
          else
            aws ecs create-service \
              --cluster "$AWS_ECS_CLUSTER" \
              --service-name "$AWS_ECS_SERVICE" \
              --task-definition "${{ steps.taskdef.outputs.task_def_arn }}" \
              --desired-count 1 \
              --launch-type FARGATE \
              --network-configuration "$NETWORK_CONFIG" \
              --load-balancers "targetGroupArn=${AWS_ECS_TARGET_GROUP_ARN},containerName=${AWS_ECS_CONTAINER_NAME},containerPort=8080" >/dev/null
          fi

      - name: Wait for ECS service stable
        shell: bash
        run: |
          set -euo pipefail
          aws ecs wait services-stable --cluster "$AWS_ECS_CLUSTER" --services "$AWS_ECS_SERVICE"

      - name: Health check
        shell: bash
        run: |
          set -euo pipefail

          URL="$AWS_BACKEND_HEALTHCHECK_URL"
          if [[ -z "$URL" ]]; then
            ALB_DNS="$(aws elbv2 describe-load-balancers --names "$AWS_ALB_NAME" --query 'LoadBalancers[0].DNSName' --output text)"
            URL="http://${ALB_DNS}"
          fi

          echo "Health check base URL: $URL"
          for i in {1..24}; do
            code="$(curl -s -o /dev/null -w "%{http_code}" "${URL}/health/" || true)"
            if [[ "$code" == "200" ]]; then
              echo "Health check passed"
              exit 0
            fi
            sleep 5
          done

          echo "::error::Health check failed for ${URL}/health/"
          exit 1
